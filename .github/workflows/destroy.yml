name: destroy
run-name: "destroy from ${{ github.ref_name }}"
concurrency:
  group: destroy-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment-name:
        type: choice
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        options:
          - ''
          - 'ci'
          - 'prod'
        default: ''
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
  workflow_call:
    inputs:
      environment-name:
        type: string
        description: 'Environment name to use instead of computing from branch, e.g. ci or prod'
        required: false
        default: ''
      deployment-name:
        type: string
        description: 'Deployment name to use instead of computing from branch, e.g. ci-lambdas6 or prod-ea373de'
        required: false
        default: ''
      sweep-for-stacks:
        type: boolean
        description: 'Whether to sweep for leftover stacks (true) or select by branch/environment/deployment name (false)'
        required: false
        default: false
  schedule:
    - cron: '34 2,4,6,8,10,12 * * *'

permissions:
  id-token: write
  contents: read

env:
  JAVA_VERSION: '21'
  NODE_VERSION: '22'
  ACTIONS_ROLE_ARN: 'arn:aws:iam::887764105431:role/submit-github-actions-role'
  DEPLOY_ROLE_ARN:  'arn:aws:iam::887764105431:role/submit-deployment-role'
  AWS_REGION: 'eu-west-2'
  AWS_ACCOUNT_ID: '887764105431'
  BASE_IMAGE_TAG_PREFIX: 'submit-base'
  GITHUB_ACTOR: ${{ github.actor }}
  SELF_DESTRUCT_DELAY_HOURS: '8'
  BASE_IMAGE_TAG: ${{ github.sha }}
  FORCE_ALL_STACK_DEPLOYMENT: 'false'
  COMMIT_HASH: ${{ github.sha }}
  BUILD_NUMBER: ${{ github.run_number }}

jobs:

  sweep-for-stacks:
    if: ${{ inputs.sweep-for-stacks || github.event.inputs.sweep-for-stacks == true || github.event_name == 'schedule' }}
    name: 'sweep for stacks'
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks in eu-west-2 and us-east-1
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      # Get last known good deployment names from SSM Parameter Store that match the ci- or prod- pattern
      - name: Get last known good deployment names
        id: last-known-good-deployment-names
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="/submit/ci/last-known-good-deployment"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="/submit/prod/last-known-good-deployment"
          echo "Getting SSM Parameter Store parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI and $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-ci.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI not found"
          aws ssm get-parameter \
            --name "$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" \
            --query "Parameter.Value" \
            --output text \
            > /tmp/last-known-good-deployment-prod.txt \
            || echo "Parameter $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD not found"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE=$(cat /tmp/last-known-good-deployment-ci.txt || echo "")
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE=$(cat /tmp/last-known-good-deployment-prod.txt || echo "")
          echo "Last known good deployment name CI: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE"
          echo "Last known good deployment name PROD: $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE"
          echo "last-known-good-deployment-name-ci=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI_VALUE" >> $GITHUB_OUTPUT
          echo "last-known-good-deployment-name-prod=$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD_VALUE" >> $GITHUB_OUTPUT

      # Get the record names of aliases in any cloudfront distributions that match the ci- or prod- pattern in the first part of the domain name
      - name: Get the published record names
        id: published-deployment-names
        run: |
          echo "Getting CloudFront distributions"
          DISTRIBUTION_IDS=$(aws cloudfront list-distributions --query "DistributionList.Items[].Id" --output text)
          PUBLISHED_DEPLOYMENT_NAMES=""
          echo "Found CloudFront Distribution IDs: $DISTRIBUTION_IDS"
          for DISTRIBUTION_ID in $DISTRIBUTION_IDS; do
            ALIASES=$(aws cloudfront get-distribution --id "$DISTRIBUTION_ID" --query "Distribution.DistributionConfig.Aliases.Items[]" --output text)
            echo "Found aliases for Distribution ID $DISTRIBUTION_ID: $ALIASES"
            for ALIAS in $ALIASES; do
              RECORD_NAME=$(echo "$ALIAS" | cut -d'.' -f1)
              if [[ "$RECORD_NAME" =~ ^(ci|prod)-.* ]]; then
                PUBLISHED_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $RECORD_NAME"
              fi
            done
          done

          # Remove duplicates
          echo "Collected published deployment names before deduplication: $PUBLISHED_DEPLOYMENT_NAMES"
          PUBLISHED_DEPLOYMENT_NAMES=$(echo $PUBLISHED_DEPLOYMENT_NAMES | tr ' ' '\n' | sort -u | tr '\n' ' ')

          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "published-deployment-names=$PUBLISHED_DEPLOYMENT_NAMES" >> $GITHUB_OUTPUT

      # Get deployment-related stack names from CloudFormation in eu-west-2 and us-east-1
      # and extract deployment IDs like ci-foo / prod-bar from:
      #   prod-64d48ac-app-OpsStack  -> prod-64d48ac
      #   ci-mtdreport-app-DevStack  -> ci-mtdreport
      - name: Get the deployed deployment names
        id: deployed-deployment-names
        run: |
          echo 'Getting deployed deployment names from CloudFormation stacks in eu-west-2 and us-east-1'

          # Only stacks that look like prod-xxx-app-...
          # Extract the deployment id: prod-xxx or ci-yyy
          DEPLOYED_DEPLOYMENT_NAMES=$(
            for REGION in eu-west-2 us-east-1; do
              echo "Scanning region: $REGION" >&2
              aws cloudformation describe-stacks \
                --region "$REGION" \
                --query 'Stacks[].StackName' \
                --output text
            done \
            | tr '\t' '\n' \
            | grep -E '^(ci|prod)-[a-zA-Z0-9-]+-(app|del)-' \
            | sed -E 's/^((ci|prod)-[a-zA-Z0-9-]+)-(app|del)-.*/\1/' \
            | sort -u
          )

          echo "Collected deployed deployment names (newline separated):"
          printf '%s\n' $DEPLOYED_DEPLOYMENT_NAMES

          # Convert to single space-separated bash-iterable string
          DEPLOYED_DEPLOYMENT_NAMES=$(echo "$DEPLOYED_DEPLOYMENT_NAMES" | tr '\n' ' ')

          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "deployed-deployment-names=$DEPLOYED_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Get the deployment names that the primary domains alias to in Route 53:
      #   submit.diyaccounting.co.uk  -> prod-*.submit.diyaccounting.co.uk.
      #   ci.submit.diyaccounting.co.uk -> ci-*.submit.diyaccounting.co.uk.
      - name: Get the public record names
        id: public-deployment-names
        run: |
          echo 'Getting Route 53 hosted zone for diyaccounting.co.uk.'
          ROOT_ZONE='diyaccounting.co.uk.'
          PRIMARY_NAMES='submit.diyaccounting.co.uk. ci.submit.diyaccounting.co.uk.'
          PUBLIC_DEPLOYMENT_NAMES=''

          ZONE_ID=$(aws route53 list-hosted-zones-by-name \
            --dns-name "$ROOT_ZONE" \
            --query 'HostedZones[0].Id' \
            --output text 2>/dev/null | sed 's|/hostedzone/||')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = 'None' ]; then
            echo "No hosted zone found for $ROOT_ZONE"
            exit 1
          fi

          echo "Using hosted zone $ROOT_ZONE ($ZONE_ID)"

          for PRIMARY_NAME in $PRIMARY_NAMES; do
            echo "Looking up alias target for $PRIMARY_NAME"

            # Get the alias target DNSName for the A record of the primary name
            ALIAS_TARGETS=$(aws route53 list-resource-record-sets \
              --hosted-zone-id "$ZONE_ID" \
              --query "ResourceRecordSets[?Name==\`$PRIMARY_NAME\` && Type==\`A\`].AliasTarget.DNSName" \
              --output text)

            if [ -z "$ALIAS_TARGETS" ] || [ "$ALIAS_TARGETS" = 'None' ]; then
              echo "No alias A record found for $PRIMARY_NAME"
              continue
            fi

            echo "Alias targets for $PRIMARY_NAME: $ALIAS_TARGETS"

            for TARGET in $ALIAS_TARGETS; do
              # Example TARGET:
              #   prod-64d48ac.submit.diyaccounting.co.uk.
              TARGET_STRIPPED=${TARGET%.}          # drop trailing dot
              HOST_LABEL=${TARGET_STRIPPED%%.*}    # first label (prod-64d48ac)

              if [[ "$HOST_LABEL" =~ ^(ci|prod)-.* ]]; then
                echo "Found public deployment from $PRIMARY_NAME -> $HOST_LABEL"
                PUBLIC_DEPLOYMENT_NAMES="$PUBLIC_DEPLOYMENT_NAMES $HOST_LABEL"
              else
                echo "Alias target $TARGET_STRIPPED does not look like ci-/prod-*, skipping"
              fi
            done
          done

          echo "Collected public deployment names before deduplication: $PUBLIC_DEPLOYMENT_NAMES"
          PUBLIC_DEPLOYMENT_NAMES=$(echo "$PUBLIC_DEPLOYMENT_NAMES" \
            | tr ' ' '\n' \
            | sort -u \
            | tr '\n' ' ')

          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "public-deployment-names=$PUBLIC_DEPLOYMENT_NAMES" >> "$GITHUB_OUTPUT"

      # Select environment and deployment names of stacks to destroy matching .*-[ci|prod]-.* pattern but not the public deployment names or last known good deployment names
      - name: Select environment and deployment names
        id: select-stack
        run: |
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-ci }}"
          LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD="${{ steps.last-known-good-deployment-names.outputs.last-known-good-deployment-name-prod }}"
          PUBLIC_DEPLOYMENT_NAMES="${{ steps.public-deployment-names.outputs.public-deployment-names }}"
          PUBLISHED_DEPLOYMENT_NAMES="${{ steps.published-deployment-names.outputs.published-deployment-names }}"
          DEPLOYED_DEPLOYMENT_NAMES="${{ steps.deployed-deployment-names.outputs.deployed-deployment-names }}"
          SELF_DESTRUCT_DELAY_HOURS="${{ env.SELF_DESTRUCT_DELAY_HOURS }}"

          echo "Last known good deployment names: CI='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI', PROD='$LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD'"
          echo "Public deployment names: $PUBLIC_DEPLOYMENT_NAMES"
          echo "Published deployment names: $PUBLISHED_DEPLOYMENT_NAMES"
          echo "Deployed deployment names: $DEPLOYED_DEPLOYMENT_NAMES"
          echo "Self-destruct delay hours: $SELF_DESTRUCT_DELAY_HOURS"

          # Function to get the most recent creation time for a deployment's stacks
          get_deployment_age_hours() {
            local deployment_name="$1"
            local most_recent_timestamp=0

            echo "Checking age of deployment: $deployment_name" >&2

            # Validate deployment name format to prevent injection
            # Only alphanumeric, hyphens allowed - safe for JMESPath query
            if ! [[ "$deployment_name" =~ ^(ci|prod)-[a-zA-Z0-9-]+$ ]]; then
              echo "Invalid deployment name format: $deployment_name" >&2
              echo "-1"
              return
            fi

            # Find all stacks for this deployment in both regions
            # The deployment_name is safe to interpolate after validation above
            for REGION in eu-west-2 us-east-1; do
              local stack_info=$(aws cloudformation describe-stacks \
                --region "$REGION" \
                --query "Stacks[?starts_with(StackName, '${deployment_name}-')].CreationTime" \
                --output text 2>/dev/null | tr '\t' '\n' || echo "")

              if [ -n "$stack_info" ]; then
                echo "Found stacks in $REGION for $deployment_name" >&2

                # Process each creation time
                while IFS= read -r creation_time; do
                  [ -z "$creation_time" ] && continue

                  # Convert creation time to epoch seconds
                  local epoch=$(date -d "$creation_time" +%s 2>/dev/null)

                  # Skip if date parsing failed or returned invalid value
                  if [ -z "$epoch" ]; then
                    echo "Failed to parse creation time: $creation_time" >&2
                    continue
                  fi

                  if ! [[ "$epoch" =~ ^[0-9]+$ ]] || [ "$epoch" -le 0 ]; then
                    echo "Invalid epoch value: $epoch for creation time: $creation_time" >&2
                    continue
                  fi

                  if [ "$epoch" -gt "$most_recent_timestamp" ]; then
                    most_recent_timestamp="$epoch"
                  fi
                done <<< "$stack_info"
              fi
            done

            if [ "$most_recent_timestamp" -eq 0 ]; then
              echo "No valid stacks found for deployment $deployment_name" >&2
              echo "-1"
              return
            fi

            # Calculate age in hours
            local current_timestamp=$(date +%s)
            local age_seconds=$((current_timestamp - most_recent_timestamp))
            local age_hours=$((age_seconds / 3600))

            echo "Deployment $deployment_name age: $age_hours hours (most recent stack created at $(date -d "@$most_recent_timestamp" -Iseconds))" >&2
            echo "$age_hours"
          }

          STACK_DEPLOYMENT_NAMES_TO_KEEP=()

          # 1. Always keep deployments that are currently aliased from the primaries
          #    plus last-known-good deployments from SSM
          for DEPLOYMENT_NAME in $(echo "$PUBLIC_DEPLOYMENT_NAMES \
            $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_CI \
            $LAST_KNOWN_GOOD_DEPLOYMENT_NAME_PROD" | tr ' ' '\n'); do
            if [ -n "$DEPLOYMENT_NAME" ]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # 2. Always keep any holding deployments that are published via CloudFront
          for DEPLOYMENT_NAME in $PUBLISHED_DEPLOYMENT_NAMES; do
            if [[ "$DEPLOYMENT_NAME" == *-holding ]]; then
              STACK_DEPLOYMENT_NAMES_TO_KEEP+=("$DEPLOYMENT_NAME")
            fi
          done

          # Remove duplicates from STACK_DEPLOYMENT_NAMES_TO_KEEP
          echo "Removing duplicates from stacks to keep from: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"
          STACK_DEPLOYMENT_NAMES_TO_KEEP=($(echo "${STACK_DEPLOYMENT_NAMES_TO_KEEP[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

          echo "Stacks to skip destruction: ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]}"

          ALL_CANDIDATE_DEPLOYMENT_NAMES="$PUBLISHED_DEPLOYMENT_NAMES $DEPLOYED_DEPLOYMENT_NAMES"

          # Remove duplicates from ALL_CANDIDATE_DEPLOYMENT_NAMES
          echo "Removing duplicates from all candidate deployment names from: $ALL_CANDIDATE_DEPLOYMENT_NAMES"
          ALL_CANDIDATE_DEPLOYMENT_NAMES=$(echo "$ALL_CANDIDATE_DEPLOYMENT_NAMES" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          # List all candidate stacks and filter out those matching STACK_DEPLOYMENT_NAMES_TO_KEEP
          # e.g.
          # SELECTED_ENVIRONMENT_NAME="ci"
          # SELECTED_DEPLOYMENT_NAME="ci-oldstack123"
          SELECTED_ENVIRONMENT_NAME=""
          SELECTED_DEPLOYMENT_NAME=""

          for DEPLOYMENT_NAME in $ALL_CANDIDATE_DEPLOYMENT_NAMES; do
            [ -z "$DEPLOYMENT_NAME" ] && continue

            echo "Considering deployment name: $DEPLOYMENT_NAME"

            if [[ " ${STACK_DEPLOYMENT_NAMES_TO_KEEP[*]} " =~ " ${DEPLOYMENT_NAME} " ]]; then
              echo "Skipping $DEPLOYMENT_NAME as it is in the keep list"
              continue
            fi

            # Check if deployment is old enough to be destroyed
            DEPLOYMENT_AGE_HOURS=$(get_deployment_age_hours "$DEPLOYMENT_NAME")

            if [ "$DEPLOYMENT_AGE_HOURS" -eq -1 ]; then
              echo "Could not determine age for $DEPLOYMENT_NAME, skipping"
              continue
            fi

            if [ "$DEPLOYMENT_AGE_HOURS" -lt "$SELF_DESTRUCT_DELAY_HOURS" ]; then
              echo "Skipping $DEPLOYMENT_NAME as it is only $DEPLOYMENT_AGE_HOURS hours old (minimum age: $SELF_DESTRUCT_DELAY_HOURS hours)"
              continue
            fi

            echo "Deployment $DEPLOYMENT_NAME is $DEPLOYMENT_AGE_HOURS hours old (>= $SELF_DESTRUCT_DELAY_HOURS hours), eligible for destruction"

            SELECTED_DEPLOYMENT_NAME="$DEPLOYMENT_NAME"

            if [[ "$SELECTED_DEPLOYMENT_NAME" == ci-* ]]; then
              SELECTED_ENVIRONMENT_NAME="ci"
              echo "Matched ci deployment for destruction"
            elif [[ "$SELECTED_DEPLOYMENT_NAME" == prod-* ]]; then
              SELECTED_ENVIRONMENT_NAME="prod"
              echo "Matched prod deployment for destruction"
            else
              echo "Deployment $SELECTED_DEPLOYMENT_NAME is not ci-/prod-, skipping"
              SELECTED_DEPLOYMENT_NAME=""
              SELECTED_ENVIRONMENT_NAME=""
              continue
            fi

            echo "Selected deployment for destruction: Environment='$SELECTED_ENVIRONMENT_NAME', Deployment='$SELECTED_DEPLOYMENT_NAME'"
            break
          done

          if [ -z "$SELECTED_DEPLOYMENT_NAME" ]; then
            echo "No stacks found for destruction"
            SWEEPER_HIT="false"
          else
            echo "Stacks found for destruction ${SELECTED_ENVIRONMENT_NAME}/${SELECTED_DEPLOYMENT_NAME}"
            SWEEPER_HIT="true"
          fi

          echo "SWEEPER_HIT=$SWEEPER_HIT"
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME"
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME"
          echo "SWEEPER_HIT=$SWEEPER_HIT" >> $GITHUB_OUTPUT
          echo "SELECTED_ENVIRONMENT_NAME=$SELECTED_ENVIRONMENT_NAME" >> $GITHUB_OUTPUT
          echo "SELECTED_DEPLOYMENT_NAME=$SELECTED_DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

    outputs:
      sweeper-hit: ${{ steps.select-stack.outputs.SWEEPER_HIT }}
      environment-name: ${{ steps.select-stack.outputs.SELECTED_ENVIRONMENT_NAME }}
      deployment-name: ${{ steps.select-stack.outputs.SELECTED_DEPLOYMENT_NAME }}

  names:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - sweep-for-stacks
    runs-on: ubuntu-24.04
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Compute deployment name and environment
        id: deployment-config
        uses: ./.github/actions/get-names
        with:
          environment-name: ${{ needs.sweep-for-stacks.outputs.environment-name || inputs.environment-name || '' }}
          deployment-name: ${{ needs.sweep-for-stacks.outputs.deployment-name || inputs.deployment-name || '' }}
    outputs:
      environment-name: ${{ steps.deployment-config.outputs.environment-name }}
      deployment-name: ${{ steps.deployment-config.outputs.deployment-name }}
      base-domain: ${{ steps.deployment-config.outputs.base-domain }}
      base-url: ${{ steps.deployment-config.outputs.base-url }}
      apex-domain: ${{ steps.deployment-config.outputs.apex-domain }}
      apex-url: ${{ steps.deployment-config.outputs.apex-url }}
      holding-domain: ${{ steps.deployment-config.outputs.holding-domain }}
      holding-url: ${{ steps.deployment-config.outputs.holding-url }}

  destroy:
    if: ${{ !cancelled() && needs.sweep-for-stacks.outputs.sweeper-hit != 'false' }}
    needs:
      - names
      - sweep-for-stacks
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'ci' }}
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.repository.default_branch }} # e.g. main
          fetch-depth: 0

      - name: Report deleted ref
        run: |
          echo "Deleted: ${{ github.event.ref }}"
          echo "Ref type: ${{ github.event.ref_type }}"

      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Configure AWS role via GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: false
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Assume AWS deployment role
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: CDK stacks before
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort

      - name: Node dependencies
        run: npm ci

      - name: Build CDK
        run: ./mvnw --errors clean verify -DskipTests

      - name: Empty origin bucket
        shell: bash
        run: |
          aws s3 rm s3://${{ needs.names.outputs.deployment-name }}-submit-app-origin-us-east-1 --recursive \
            || echo "Origin bucket already empty or does not exist"

      - name: Destroy Submit Application
        run: |
          cd cdk-application && \
            npx dotenv -e ../.env.${{ needs.names.outputs.environment-name }} -- \
              npx cdk destroy \
              --all \
              --force \
          && cd .. \
          ;
        env:
          ENVIRONMENT_NAME: ${{ needs.names.outputs.environment-name }}
          DEPLOYMENT_NAME: ${{ needs.names.outputs.deployment-name }}
          BASE_IMAGE_TAG: "${{ env.BASE_IMAGE_TAG }}:latest"
          # Set by deploy-environment.yml after the environment's AuthStack is deployed
          COGNITO_USER_POOL_ARN: ${{ vars.COGNITO_USER_POOL_ARN }}
          COGNITO_CLIENT_ID: ${{ vars.COGNITO_CLIENT_ID }}
          WEBSITE_HASH: 'placeholder'
          HTTP_API_URL: 'https://placeholder'

      - name: CDK stacks after
        if: ${{ !cancelled() }}
        run: |
          aws cloudformation describe-stacks --region eu-west-2 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
          aws cloudformation describe-stacks --region us-east-1 --query "Stacks[].StackName" --output text | tr '\t' '\n' | sort
