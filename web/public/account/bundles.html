<!-- account/bundles.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HARD COPY - The Quiet Feed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../submit.css" />
    <meta name="rum:appMonitorId" content="${RUM_APP_MONITOR_ID}" />
    <meta name="rum:region" content="${AWS_REGION}" />
    <meta name="rum:identityPoolId" content="${RUM_IDENTITY_POOL_ID}" />
    <meta name="rum:guestRoleArn" content="${RUM_GUEST_ROLE_ARN}" />
  </head>
  <body>
    <header>
      <div class="header-nav">
        <nav class="nav-links">
          <a href="../index.html" class="nav-link">Feed</a>
          <a href="../index.html?feed=about" class="nav-link">About</a>
          <a href="../index.html?feed=settings" class="nav-link active">Settings</a>
        </nav>
        <div class="header-brand">
          <span class="system-prefix">SYSTEM://</span>
          <span class="brand-title">THE QUIET FEED</span>
        </div>
        <div class="auth-section">
          <span class="login-status" id="loginStatus">ANONYMOUS</span>
          <a href="../auth/login.html" class="login-link" id="authLink">ENHANCE</a>
        </div>
      </div>
      <p class="subtitle">HARD COPY subscription</p>
    </header>

    <main id="mainContent">
      <div id="statusMessagesContainer"></div>
      <div id="loadingSpinner" class="spinner" style="display: none"></div>

      <div class="form-container">
        <h2>HARD COPY</h2>
        <p style="color: var(--color-text-secondary); margin-bottom: 2rem;">
          Unlock full access to The Quiet Feed
        </p>

        <div id="catalogBundles"></div>

        <div id="currentBundles" style="margin-top: 2rem;"></div>
      </div>
    </main>

    <footer>
      <div class="footer-content">
        <div class="footer-left">
          <a href="../tests/index.html" target="_blank">tests</a>
          <a href="../docs/index.html" target="_blank">api</a>
          <a href="../privacy.html">privacy</a>
          <a href="../terms.html">terms</a>
        </div>
        <div class="footer-center">
          <p>&copy; 2025-2026 Antony Cartwright</p>
        </div>
        <div class="footer-right" id="localstorageContainer"></div>
      </div>
    </footer>

    <script type="module" src="../submit.js"></script>
    <script src="../lib/request-cache.js"></script>
    <script src="../lib/bundle-cache.js"></script>
    <script src="../lib/toml-parser.js"></script>
    <script src="../widgets/auth-status.js"></script>
    <script src="../widgets/status-messages.js"></script>
    <script src="../widgets/loading-spinner.js"></script>
    <script src="../widgets/localstorage-viewer.js"></script>

    <script>
      const getIdToken = () => {
        try {
          return localStorage.getItem("cognitoIdToken");
        } catch (e) {
          return null;
        }
      };

      const __rc = typeof window !== "undefined" && window.requestCache ? window.requestCache : null;
      const fetchAndParse = async (url, opts = {}) => {
        try {
          if (__rc && typeof __rc.getJSON === "function" && !url.endsWith(".toml")) return __rc.getJSON(url, opts);
        } catch {}
        const init = opts.init || {};
        const hasAuthHeader = init.headers && (init.headers.Authorization || init.headers.authorization);
        let res;
        if (hasAuthHeader && window.fetchWithIdToken) {
          res = await window.fetchWithIdToken(url, init);
        } else {
          res = await fetch(url, init);
        }
        try {
          if (url.endsWith(".toml")) {
            const text = await res.text();
            return window.TOML ? window.TOML.parse(text) : null;
          }
          return await res.json();
        } catch {
          return null;
        }
      };

      const invalidate = (prefix) => {
        try {
          if (__rc && typeof __rc.invalidate === "function") return __rc.invalidate(prefix);
        } catch {}
      };

      let __userBundles = [];
      let __fetchBundlesController = null;

      const parseUserBundles = () => (Array.isArray(__userBundles) ? __userBundles : []);

      const fetchUserBundles = async () => {
        const idToken = getIdToken();
        if (!idToken) {
          __userBundles = [];
          return __userBundles;
        }

        const userInfoJson = localStorage.getItem("userInfo");
        let userId = null;
        try {
          const userInfo = JSON.parse(userInfoJson);
          userId = userInfo && userInfo.sub;
        } catch {}

        if (userId) {
          const cached = await window.bundleCache.getBundles(userId);
          if (cached && Array.isArray(cached)) {
            __userBundles = cached;
            return __userBundles;
          }
        }

        if (__fetchBundlesController) {
          __fetchBundlesController.abort();
        }
        __fetchBundlesController = new AbortController();
        const signal = __fetchBundlesController.signal;

        try {
          const bundlesData = await fetchAndParse("/api/v1/bundle", {
            ttlMs: 0,
            init: { headers: { Authorization: `Bearer ${idToken}` }, signal },
          });
          if (bundlesData && bundlesData.bundles && Array.isArray(bundlesData.bundles)) {
            __userBundles = bundlesData.bundles.map((b) => b.bundleId);
            if (userId) {
              await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
            }
            return __userBundles;
          }
        } catch (err) {
          if (err.name === "AbortError") {
            return __userBundles;
          }
          console.warn("Failed to fetch bundles:", err);
        } finally {
          if (__fetchBundlesController?.signal === signal) {
            __fetchBundlesController = null;
          }
        }
        __userBundles = [];
        return __userBundles;
      };

      const hasBundle = (bundles, id) =>
        (bundles || []).some((b) => {
          if (typeof b === "string") return b === id;
          return b?.bundleId === id;
        });

      const markToRequest = (btn, message = "Subscribe") => {
        btn.textContent = message;
        btn.disabled = false;
        btn.style.backgroundColor = "var(--color-accent)";
      };

      const markGranted = (btn, message = "Active") => {
        btn.textContent = message;
        btn.disabled = true;
        btn.style.backgroundColor = "var(--color-success)";
      };

      async function requestBundle(bundleId, bundleName, qualifiers = {}, fireAndForget = true) {
        const idToken = getIdToken();
        if (!idToken) {
          showStatus("Please sign in to ENHANCE first.", "warning");
          window.location.href = "../auth/login.html";
          return false;
        }

        try {
          const r = await window.fetchWithIdToken("/api/v1/bundle", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            fireAndForget,
            body: JSON.stringify({ bundleId, qualifiers }),
          });
          const body = await r.json().catch(() => ({}));

          if (r.ok) {
            if (r.status === 202 || body.status === "granted" || body.status === "already_granted") {
              showStatus(`${bundleName} activated successfully.`, "success");
              if (!hasBundle(__userBundles, bundleId)) {
                __userBundles.push(bundleId);
              }
              const userInfoJson = localStorage.getItem("userInfo");
              let userId = null;
              try {
                const userInfo = JSON.parse(userInfoJson);
                userId = userInfo && userInfo.sub;
              } catch {}
              if (userId) {
                await window.bundleCache.setBundles(userId, __userBundles, 5 * 60 * 1000);
              }
              invalidate("/api/v1/bundle");
              try { renderCurrentBundles(); } catch {}
              try { updateBundleStatus(); } catch {}
              return true;
            }
          } else {
            showStatus(`Failed: ${body.error || "Unknown error"}`, "error");
          }
        } catch (err) {
          showStatus(`Error: ${err?.message || err}.`, "error");
        }
        return false;
      }

      const cardHtml = (b) => {
        const rawName = (b && (b.name || b.id)) || "";
        const safeName = String(rawName).replace(/\"/g, "&quot;");
        return `
          <div class="tier-card featured" style="max-width: 400px; margin: 0 auto;">
            <div class="tier-name">${rawName}</div>
            <p style="color: var(--color-text-secondary); margin: 1rem 0;">
              ${b.description || 'Full access to all features'}
            </p>
            <ul class="tier-features">
              <li>WIRE MODE headline normalization</li>
              <li>Advanced DEDUP clustering</li>
              <li>API access</li>
              <li>TERM CLI</li>
              <li>Data export</li>
            </ul>
            <button type="button" class="btn" data-bundle-id="${b.id}" data-bundle-name="${safeName}"
              style="width: 100%; margin-top: 1rem;">
              Subscribe to ${rawName}
            </button>
          </div>`;
      };

      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("button[data-bundle-id]");
        if (!btn) return;

        const bundleId = btn.getAttribute("data-bundle-id");
        const bundleName = btn.getAttribute("data-bundle-name") || bundleId;
        const original = btn.textContent;

        btn.textContent = "Processing...";
        btn.disabled = true;

        const success = await requestBundle(bundleId, bundleName, {}, true);
        if (success) {
          markGranted(btn, `${bundleName} Active`);
        } else {
          btn.textContent = original;
          btn.disabled = false;
        }
      });

      function updateBundleStatus() {
        const bundles = parseUserBundles();
        document.querySelectorAll("button[data-bundle-id]").forEach((btn) => {
          const id = btn.getAttribute("data-bundle-id");
          const name = btn.getAttribute("data-bundle-name") || id;
          if (hasBundle(bundles, id)) {
            markGranted(btn, `${name} Active`);
          } else {
            markToRequest(btn, `Subscribe to ${name}`);
          }
        });
      }

      (async function () {
        const container = document.getElementById("catalogBundles");
        try {
          await fetchUserBundles();
          try { renderCurrentBundles(); } catch {}

          const idToken = getIdToken();
          const headers = idToken ? { Authorization: `Bearer ${idToken}` } : undefined;
          const catalog = await fetchAndParse("/submit.catalogue.toml", {
            ttlMs: 300000,
            init: headers ? { headers } : undefined,
          });

          if (!catalog || !catalog.bundles) {
            container.innerHTML = '<p style="color: var(--color-text-secondary);">HARD COPY coming soon.</p>';
            return;
          }

          // Filter for HARD COPY bundle only
          const hardCopyBundles = (catalog.bundles || [])
            .filter((b) => b.id && b.id.toLowerCase().includes('hard'));

          if (hardCopyBundles.length === 0) {
            // Show default HARD COPY card
            container.innerHTML = `
              <div class="tier-card featured" style="max-width: 400px; margin: 0 auto;">
                <div class="tier-name">HARD COPY</div>
                <p style="color: var(--color-text-secondary); margin: 1rem 0;">
                  Full access to all features
                </p>
                <ul class="tier-features">
                  <li>WIRE MODE headline normalization</li>
                  <li>Advanced DEDUP clustering</li>
                  <li>API access</li>
                  <li>TERM CLI</li>
                  <li>Data export</li>
                </ul>
                <button type="button" class="btn" style="width: 100%; margin-top: 1rem;" disabled>
                  Coming Soon
                </button>
              </div>`;
          } else {
            container.innerHTML = hardCopyBundles.map(cardHtml).join("\n");
          }
          updateBundleStatus();
        } catch (err) {
          console.error("[bundles.html] Error:", err);
          container.innerHTML = '<p style="color: var(--color-text-secondary);">Failed to load.</p>';
        }
      })();

      function renderCurrentBundles() {
        const container = document.getElementById("currentBundles");
        const bundles = parseUserBundles();

        if (bundles.length === 0) {
          container.innerHTML = '';
          return;
        }

        const bundleCards = bundles
          .map((bundleEntry) => {
            const bundleId = typeof bundleEntry === "string" ? bundleEntry : bundleEntry.bundleId;
            return `
            <div style="background: var(--color-surface); border-radius: 8px; padding: 1rem; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
              <span style="font-family: var(--font-mono);">${bundleId}</span>
              <span style="color: var(--color-success); font-family: var(--font-mono); font-size: 0.875rem;">ACTIVE</span>
            </div>`;
          })
          .join("");

        container.innerHTML = `<h3 style="margin-bottom: 1rem;">Your Subscriptions</h3>${bundleCards}`;
      }

      try { sessionStorage.removeItem("currentActivity"); } catch {}

      function initPage() {
        checkAuthStatus();
      }

      if (window.__submitReady__) {
        initPage();
      } else {
        document.addEventListener("submit-ready", initPage, { once: true });
      }
    </script>
  </body>
</html>
